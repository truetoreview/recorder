<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pro Recorder - Real-time Scroll</title>
    <link rel="manifest" href="manifest.json">
<script>
  if ('serviceWorker' in navigator) {
    navigator.serviceWorker.register('sw.js');
  }
</script>
    <style>
        :root { --primary: #6366f1; --danger: #ef4444; --bg: #0f172a; --card: #1e293b; }
        body { 
            font-family: sans-serif; background: var(--bg); color: white; 
            display: flex; flex-direction: column; align-items: center; 
            padding: 15px; margin: 0; min-height: 100vh;
        }
        .card { 
            background: var(--card); padding: 1.5rem; border-radius: 24px; 
            text-align: center; width: 100%; max-width: 420px; box-sizing: border-box;
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }
        #visualizer { 
            width: 100%; height: 140px; background: #070b14; 
            border-radius: 16px; margin: 15px 0; border: 1px solid #334155;
            display: block;
        }
        .timer { font-size: 3rem; font-weight: bold; margin: 5px 0; font-family: 'Courier New', monospace; color: #e2e8f0; }
        button { 
            width: 100%; padding: 18px; border-radius: 14px; border: none; 
            font-weight: bold; font-size: 1.1rem; cursor: pointer; margin-top: 10px;
            transition: transform 0.1s;
        }
        button:active { transform: scale(0.98); }
        #startBtn { background: var(--primary); color: white; }
        #stopBtn { background: var(--danger); color: white; display: none; }
        button:disabled { background: #475569; opacity: 0.6; cursor: not-allowed; }
        .msg { margin-top: 15px; color: #94a3b8; font-size: 0.9rem; display: none; line-height: 1.4; }
        #status { font-weight: bold; letter-spacing: 1px; color: #94a3b8; }
    </style>
</head>
<body>

<div class="card" id="mainCard">
    <div id="status">READY</div>
    <div class="timer" id="timer">00:00</div>
    <canvas id="visualizer"></canvas>
    
    <button id="startBtn">Start Recording</button>
    <button id="stopBtn">Stop & Download</button>
    <div id="reloadMsg" class="msg"><b>Session Locked.</b><br>Reload the page to start a new recording.</div>
</div>

<script>
    let audioCtx, processor, analyser, audioStream;
    let wavChunks = [];
    let timerInterval, seconds = 0;
    let volumeHistory = [];
    let isRecording = false;

    const startBtn = document.getElementById('startBtn');
    const stopBtn = document.getElementById('stopBtn');
    const timerDisplay = document.getElementById('timer');
    const canvas = document.getElementById('visualizer');
    const canvasCtx = canvas.getContext("2d", { alpha: false });

    // Handle high-DPI displays for sharpness
    const dpr = window.devicePixelRatio || 1;
    canvas.width = canvas.offsetWidth * dpr;
    canvas.height = canvas.offsetHeight * dpr;
    canvasCtx.scale(dpr, dpr);

    function encodeWAV(samples, sampleRate) {
        let buffer = new ArrayBuffer(44 + samples.length * 2);
        let view = new DataView(buffer);
        const writeString = (off, s) => { for (let i=0; i<s.length; i++) view.setUint8(off+i, s.charCodeAt(i)) };
        writeString(0, 'RIFF');
        view.setUint32(4, 32 + samples.length * 2, true);
        writeString(8, 'WAVE');
        writeString(12, 'fmt ');
        view.setUint32(16, 16, true);
        view.setUint16(20, 1, true);
        view.setUint16(22, 1, true);
        view.setUint32(24, sampleRate, true);
        view.setUint32(28, sampleRate * 2, true);
        view.setUint16(32, 2, true);
        view.setUint16(34, 16, true);
        writeString(36, 'data');
        view.setUint32(40, samples.length * 2, true);
        for (let i = 0; i < samples.length; i++) {
            let s = Math.max(-1, Math.min(1, samples[i]));
            view.setInt16(44 + (i * 2), s < 0 ? s * 0x8000 : s * 0x7FFF, true);
        }
        return new Blob([view], { type: 'audio/wav' });
    }

    startBtn.onclick = async () => {
        try {
            audioStream = await navigator.mediaDevices.getUserMedia({ audio: true });
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            
            analyser = audioCtx.createAnalyser();
            analyser.fftSize = 256;
            const input = audioCtx.createMediaStreamSource(audioStream);
            processor = audioCtx.createScriptProcessor(2048, 1, 1);

            input.connect(analyser);
            input.connect(processor);
            processor.connect(audioCtx.destination);

            processor.onaudioprocess = (e) => {
                if (!isRecording) return;
                const data = e.inputBuffer.getChannelData(0);
                wavChunks.push(new Float32Array(data));
                
                let peak = 0;
                for(let i=0; i<data.length; i++) {
                    let abs = Math.abs(data[i]);
                    if(abs > peak) peak = abs;
                }
                
                // Add new volume data
                volumeHistory.push(peak);
                
                // Keep enough bars to fill the screen, plus some extra
                const maxBars = Math.floor(canvas.offsetWidth / 6); 
                if(volumeHistory.length > maxBars) {
                    volumeHistory.shift();
                }
            };

            isRecording = true;
            startBtn.style.display = 'none';
            stopBtn.style.display = 'block';
            document.getElementById('status').innerText = "RECORDING";
            document.getElementById('status').style.color = "#ef4444";
            
            startTimer();
            draw();
        } catch (err) {
            alert("Mic access is required for this app to work.");
        }
    };

    stopBtn.onclick = () => {
        isRecording = false;
        startBtn.disabled = true;
        stopBtn.disabled = true;
        
        audioStream.getTracks().forEach(t => t.stop());
        clearInterval(timerInterval);

        let totalLength = wavChunks.reduce((acc, curr) => acc + curr.length, 0);
        let result = new Float32Array(totalLength);
        let offset = 0;
        for (let chunk of wavChunks) { result.set(chunk, offset); offset += chunk.length; }

        const blob = encodeWAV(result, audioCtx.sampleRate);
        const url = URL.createObjectURL(blob);
        
        const n = new Date();
        const timestamp = `${n.getDate()}-${n.getMonth()+1}-${n.getFullYear()}-${n.getHours()}-${n.getMinutes()}-${n.getSeconds()}`;
        
        const a = document.createElement('a');
        a.href = url;
        a.download = `${timestamp}.wav`;
        a.click();

        document.getElementById('status').innerText = "SAVED";
        document.getElementById('status').style.color = "#10b981";
        document.getElementById('reloadMsg').style.display = 'block';
    };

    function startTimer() {
        timerInterval = setInterval(() => {
            seconds++;
            let m = Math.floor(seconds / 60).toString().padStart(2, '0');
            let s = (seconds % 60).toString().padStart(2, '0');
            timerDisplay.innerText = `${m}:${s}`;
        }, 1000);
    }

    function draw() {
        if (!isRecording) return;
        requestAnimationFrame(draw);

        const width = canvas.offsetWidth;
        const height = canvas.offsetHeight;
        const midY = height / 2;
        
        // Fixed Cursor Position (75% of the way to the right)
        const cursorX = width * 0.75;
        const barWidth = 3;
        const gap = 2;
        const step = barWidth + gap;

        canvasCtx.fillStyle = "#070b14";
        canvasCtx.fillRect(0, 0, width, height);

        // Draw the bars relative to the cursor
        // The most recent bar (last in array) is drawn at cursorX
        for (let i = 0; i < volumeHistory.length; i++) {
            const barData = volumeHistory[volumeHistory.length - 1 - i];
            const h = Math.max(4, barData * height * 1.5);
            const x = cursorX - (i * step);

            if (x < -barWidth) break; // Don't draw bars off the left edge

            canvasCtx.fillStyle = "#6366f1";
            // Rounded bar effect
            canvasCtx.beginPath();
            canvasCtx.roundRect(x, midY - h/2, barWidth, h, 2);
            canvasCtx.fill();
        }

        // Draw the Red Cursor Line
        canvasCtx.fillStyle = "#ef4444";
        canvasCtx.fillRect(cursorX, 0, 2, height);
    }

    // Initial state
    canvasCtx.fillStyle = "#070b14";
    canvasCtx.fillRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
</script>
</body>
</html>
